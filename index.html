<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Neon Cube</title>

    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        background-color: black;
      }

      #bgContainer {
        position: relative;
        height: 100%;
        z-index: 0;
      }

      #bgContainer::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        /* background: radial-gradient(circle, rgba(80,143,174,1) 0%, rgba(0,0,0,1) 100%); */
        /* opacity: 0.85; */
        z-index: -1;
        transition: 0.2s ease;
      }

      #bgContainer.active::before {
        opacity: 1;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
        z-index: -1;
      }

      #big-img-hldr{
        position: absolute;
        z-index: 100;
        background: #0000007a;
        height: 100vh;
        width: 100vw;
        top: 0;
        left: 0;
      }

      #contentOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        /*pointer-events: none;*/
        opacity: 0;
        background: #0000008c;
        -webkit-transition: 0.5s ease;
        transition: 0.5s ease;
      }

#contentOverlay #closeVideoBtn {
  position: absolute;
  top: 0.75em;
  right: 0.75em;
  cursor: pointer;
  font-size: 2.4em;
  color: #000;
}

#contentOverlay #closeVideoBtn img {
  width: 30px;
  height: 30px;
}

#contentOverlay #video {
  width: 80%;
  max-height: 90vh;
  margin: 2% auto;
  -o-object-fit: contain;
     object-fit: contain;
  opacity: 0;
  display: none;
  -webkit-transition: 0.5s ease;
  transition: 0.5s ease;
}

#contentOverlay .content {
  opacity: 0;
  display: none;
  pointer-events: none;
  text-align: center;
  -webkit-transition: 0.2s ease;
  transition: 0.2s ease;
}

#contentOverlay .content img {
  width: 80%;
  max-height: 90vh;
  margin: 2% auto;
  -o-object-fit: contain;
     object-fit: contain;
}

#contentOverlay .content.show {
  opacity: 1;
  display: block;
  pointer-events: all;
}

#contentOverlay.show {
  opacity: 1;
  z-index: 9;
  pointer-events: all;
}

#contentOverlay.show #video {
  opacity: 1;
  display: block;
}

#myVideo {
  position: fixed;
  right: 0;
  top: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: -1;
}
    </style>

    <script src="./js/babylon.max.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  </head>

  <body>
    <div id="bgContainer">
      <!-- <video autoplay muted loop id="myVideo">
        <source src="assets/bg-video.mp4" type="video/mp4">
      </video> -->
      <canvas id="renderCanvas" touch-action="none"></canvas>
    </div>
    <!-- touch-action="none" for best results from PEP -->

    <div id="contentOverlay">
      <!-- <div id="closeVideoBtn" onclick="toggleContentOverlay()">
          <img src="./assets/close.png" alt="Close button">
      </div> -->
      <div class="content" id="left-image">
          <video id="video" crossOrigin="anonymous" playsinline>
              <source src="./assets/Back_compressed.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"'>
          </video>
      </div>
      <div class="content" id="front-image">
          <img style="transform: scaleY(-1);" src="./assets/Left.jpeg" alt="">
      </div>
      <div class="content" id="back-image">
          <img style="transform: scaleY(-1);" src="./assets/Right.jpeg" alt="">
      </div>
      <div class="content" id="right-image">
          <img style="transform: scaleY(-1);" src="./assets/Front.jpeg" alt="">
      </div>
  </div>
    <script>
      const canvas = document.getElementById("renderCanvas"); // Get the canvas element
      const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
      let backImg;

      const contentOverlay = document.getElementById('contentOverlay');
      const frontBigImg = document.getElementById('front-image');
      const backBigImg = document.getElementById('back-image');
      const rightBigImg = document.getElementById('right-image');
      const leftBigImg = document.getElementById('left-image');
      const video = document.getElementById('video');
      const bgContainer = document.getElementById('bgContainer');

      let mouseX, scene = null, cubeModel = null, isMouseDown = false, isDragging = false, cubeFaceMat = false, rotation = 0, step = (Math.PI/4.00), envVolume = 0.03, gl = null;

      let meshArrayGlow = [],
      meshArrayNotGlow = [],
      materialsToAnimate = []

      let timePointerDown, timePointerUp, camera;

      let hasDragEnded = true;
      // Add your code here matching the playground format
      const createScene = function () {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.02, 0.02, 0.02, 0);
        //scene.createDefaultCamera(true);
        scene.environmentIntensity = 0;
        //BABYLON.MeshBuilder.CreateBox("box", {});

        //load Modelf
        BABYLON.SceneLoader.Append("./assets/", "Cube_02_ static.glb", scene, function (meshes) {
        
          gl = new BABYLON.GlowLayer("glow", scene, { 
              mainTextureSamples: 8,
              blurKernelSize: 72
          });

          gl.intensity = 1;

          cubeModel = scene.meshes[0];
          cubeModel.rotationQuaternion = null
          scene.meshes[0].scaling.scaleInPlace(1.8);
          
          //scene.meshes[0].scaling.scaleInPlace(0.3);
          // scene.meshes[0].scaling = new BABYLON.Vector3(2,2,2);
          scene.meshes[0].position = new BABYLON.Vector3(0,.2,0);
          
          scene.meshes.forEach(element => {
            if(element.name != 'Cube' && element.name != '__root__') {
              if(element.name == '1' || element.name == '2' || element.name == '3' || element.name == '4') {
                meshArrayGlow.push(element)
              }else {
                meshArrayNotGlow.push(element)
              }
            }
          });

          scene.materials.forEach(element => {
            if(element.name == 'Material.016' || element.name == 'Material.015' || element.name == 'Material.012' || element.name == 'Material.009') {
              materialsToAnimate.push(element)
              element.alpha = 0
              element.MATERIAL_ALPHABLEND = true
            }
          });

          meshArrayNotGlow.forEach(element => {
            gl.addExcludedMesh(element);
            element.setEnabled(false)
          });

          meshArrayGlow.forEach(element => {
            element.setEnabled(false)
          });
          
          scene.environmentTexture = new BABYLON.CubeTexture("./assets/cubetexture/", scene);
          // var light2 = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene);
          // light2.intensity = 0.5
          //scene.environmentIntensity = 6.0;

          let goldMat = scene.getMaterialByName("Material.003");
          goldMat.emissiveColor = new BABYLON.Color3.FromHexString("#1f80ff");
          goldMat.emissiveIntensity = 1.5;


          // cubeFaceMat = scene.getMaterialByName("Material");
          // cubeFaceMat.alpha = 0;


          // goldMat = scene.getMaterialByName("Material.002");
          // goldMat.emissiveColor = new BABYLON.Color3.FromHexString("#FFD700");
          // goldMat.roughness = 0.1;
          // goldMat.metallic = 0.9;
          // goldMat.emissiveIntensity = 0.4;

          // goldMat = scene.getMaterialByName("Material.003");
          // goldMat.emissiveColor = new BABYLON.Color3.FromHexString("#FFD700");
          // goldMat.roughness = 0.1;
          // goldMat.metallic = 0.9;
          // goldMat.emissiveIntensity = 0.4;

          // goldMat = scene.getMaterialByName("Material.004");
          // goldMat.emissiveColor = new BABYLON.Color3.FromHexString("#FFD700");
          // goldMat.roughness = 0.1;
          // goldMat.metallic = 0.9;
          // goldMat.emissiveIntensity = 0.4;
          
          // Mirror

          var light = new BABYLON.PointLight("light1", new BABYLON.Vector3(0, 10, 0), scene);
          light.intensity = .2;
          // Mirror
          const cubeMesh = scene.getMeshByName("Cube");
          // Mirror
          var mirror = BABYLON.Mesh.CreateBox("Mirror", 1.0, scene);
          mirror.scaling = new BABYLON.Vector3(500.0, 0.01, 500.0);
          mirror.material = new BABYLON.StandardMaterial("mirror", scene);
          mirror.material.color = new BABYLON.Color3.FromHexString("#000000");
          // mirror.material.emissiveIntensity = 0.4;
          mirror.material.reflectionTexture = new BABYLON.MirrorTexture("mirror", {ratio: 1.5}, scene, true);
          mirror.material.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, -1.0, 0, -2.0);
          mirror.material.reflectionTexture.renderList = meshArrayNotGlow.concat(meshArrayGlow);
          mirror.material.reflectionTexture.level = 1.0;
          mirror.material.reflectionTexture.level = 1.0;
          // mirror.material.roughness = 2.0
          mirror.position = new BABYLON.Vector3(0, -25, -40);	
          gl.addExcludedMesh(mirror);
          materialsToAnimate.push(mirror.material)

          // Main material	

          // Fog
          scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
          scene.fogColor = scene.clearColor;
          scene.fogStart = 10.0;
          scene.fogEnd = 100.0;
          
          meshArrayNotGlow.forEach(element => {
            gl.addExcludedMesh(element);
            element.setEnabled(false)
          });
    
      });

        camera = new BABYLON.ArcRotateCamera("camera", 0, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0));
        const c = Math.PI /2.0;
        camera.radius - 15.0;
        camera.lowerBetaLimit = c;
        camera.upperBetaLimit = c;
        
        camera.idleRotationWaitTime = 6000;
        camera.panningAxis = new BABYLON.Vector3(0,0,0);
        camera.angularSensibilityX = 10000;
        camera.angularSensibilityY = 10000;

        camera.attachControl(canvas, true);
        // camera.inputs.remove(camera.inputs.attached.mousewheel);
        //const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

        return scene;
      };

      scene = createScene(); //Call the createScene function

      //Audio
      var music = new BABYLON.Sound("music", "./assets/envAudio.wav", scene,null, {
        volume: envVolume,
        loop: true
      });

      let musicPlayed = false

      const mouseClick = new BABYLON.Sound("mouseClick", "./assets/mouse-click.wav", scene,null, {
        volume: 0.2
      });

      //Audio
      let animationIntervalTimer = 150
      let animationCounter = 0
      let animInterval = null
      let totalAnimCount = 0

      function flickerAnimationInterval() {
        animInterval = setInterval(() => {
          flickerAnimateCube()
        }, animationIntervalTimer);
      }

      function flickerAnimateCube() {
        if(scene != null && cubeModel != null) {
          let cubeMesh = scene.getMeshByName("Cube");
          if(animationCounter == 3) {
            totalAnimCount++
            meshArrayNotGlow.forEach(element => {
              element.setEnabled(true)
            });
            clearInterval(animInterval)
            if(totalAnimCount == 1) {
              gl.intensity = 0.1
              meshArrayGlow.forEach(element => {
                element.setEnabled(false)
              });
            }
            if(totalAnimCount < 1) {
              setTimeout(() => {
                if(totalAnimCount == 0) {
                  meshArrayNotGlow.forEach(element => {
                    element.setEnabled(false)
                  });
                }
                meshArrayGlow.forEach(element => {
                  element.setEnabled(false)
                });
                animationIntervalTimer = 220
                animationCounter = -1
              }, 1500);
            }else {
              animateEnvMapInt()
            }
          }else {
            if(cubeMesh) {
              meshArrayGlow.forEach(element => {
                element.setEnabled(false)
              });
              setTimeout(() => {
                meshArrayGlow.forEach(element => {
                  element.setEnabled(true)
                });
              }, 75);
              // animationIntervalTimer = +animationIntervalTimer - 100
              animationCounter ++
            }
          }
        }
      }

      setTimeout(() => {
        flickerAnimationInterval()
      }, 1500);

      function animateEnvMapInt() {
        materialsToAnimate.forEach(element => {
          element.visibility = 0
          element.transparencyMode = 3
        });
        meshArrayGlow.forEach(element => {
          element.setEnabled(true)
        });
        setTimeout(() => {
          materialsToAnimate.forEach(element => {
            new TWEEN.Tween(element)
            .to({alpha : 1 }, 1500)
            .start(); 
          });
        }, 500);

        setTimeout(() => {
          const animation = new TWEEN.Tween(scene)
          .to({environmentIntensity : 0.35 }, 2000)
          .start() 
        }, 1500);

        new TWEEN.Tween(gl)
        .to({intensity : 1 }, 2000)
        .start()
        .onComplete(function() {
          setTimeout(() => {
            camera.attachControl(canvas, true);   
            camera.useAutoRotationBehavior = true;
          }, 4000);
        });  ;

      }

      scene.onPointerUp = function () {
        let toAnimateCamera = false,
        cameraAlphaVal = null
        isMouseDown = false

        if(isDragging) {
          setTimeout(() => {
            isDragging = false
          }, 100);
        }

        if(!isDragging){

          var pickResult = scene.pick(scene.pointerX, scene.pointerY);

          if (pickResult.hit && !isDragging) {
            const clickedMeshName = pickResult.pickedMesh.name; 

            console.log(clickedMeshName,camera.radius);
            if(camera.radius != 12) {
              if(clickedMeshName === "Front glass panel" || clickedMeshName === "Front glass panel gold "){
                toAnimateCamera = true
                cameraAlphaVal = -Math.PI / 4.0;
              }else if(clickedMeshName === "back glass panel" || clickedMeshName === "back glass panel gold"){
                toAnimateCamera = true
                cameraAlphaVal = 3 * (Math.PI / 4.0);
              }else if(clickedMeshName === "Left glass panel" || clickedMeshName === "Left glass panel_gold" ){
                toAnimateCamera = true
                cameraAlphaVal = 5 * (Math.PI / 4.0);
                backImg.video.currentTime = 0
                backImg.video.muted = false

              }else if(clickedMeshName === "Right glass panel" || clickedMeshName === "Right glass panel gold"){
                toAnimateCamera = true
                cameraAlphaVal = Math.PI / 4.0;
              }else {
                toAnimateCamera = false
              }

              if(toAnimateCamera) {
                camera.useAutoRotationBehavior = false;
                const rotation = ((~~(camera.alpha/(2*Math.PI)))* 2*Math.PI) + cameraAlphaVal
                camera.detachControl(canvas, true);

                new TWEEN.Tween(camera)
                .to({alpha : rotation }, 1000)
                .easing(TWEEN.Easing.Exponential.In)
                .start(); 

                new TWEEN.Tween(camera)
                .to({radius : 12.0 }, 1500)
                .easing(TWEEN.Easing.Exponential.In)
                .start(); 
              }
            }else if(camera.radius != 15) {
              new TWEEN.Tween(camera)
              .to({radius : 15.0 }, 1200)
              .easing(TWEEN.Easing.Exponential.InOut)
              .start(); 
              setTimeout(() => {
                camera.attachControl(canvas, true);   
                camera.useAutoRotationBehavior = true;    
                backImg.video.muted = true
              }, 1000);
            }


          }else {
            if(camera.radius != 15) {
              new TWEEN.Tween(camera)
              .to({radius : 15.0 }, 1200)
              .easing(TWEEN.Easing.Exponential.InOut)
              .start(); 
              setTimeout(() => {
                camera.attachControl(canvas, true);   
                camera.useAutoRotationBehavior = true;
                backImg.video.muted = true
              }, 1000);
            }
          }

        }else{
          new TWEEN.Tween(camera)
          .to({radius : 15.0 }, 200)
          // .easing(TWEEN.Easing.Linear.InOut)
          .start();
        }


        if(backImg) {
          backImg.video.play();
        }


        //setTimeout(() => {
          //isDragging = false;
        //}, 300);

        //rotation = Math.round(cubeModel.rotation.y / step) * step; 
        
        /*new TWEEN.Tween(cubeModel.rotation)
        .to({y: rotation }, 600)
        .easing(TWEEN.Easing.Back.Out)
        .onComplete(() => {
          
        })
        .start(); */
      
      }

      scene.onPointerDown = function(event){
        isMouseDown = true
        mouseX = event.layerX;
        mouseClick.play()

        if(!musicPlayed) {
          music.play()
          if(music.isPlaying) {
            musicPlayed = true
            setTimeout(() => {
              const musicInterval = setInterval(() => {
                if(envVolume <= 0) {
                  clearInterval(musicInterval)
                  music.stop()
                }
                envVolume -= 0.001
                music.setVolume(envVolume);
              }, 250);
            }, 7000);
          }
        }

        if(camera.radius == 15) {
          new TWEEN.Tween(camera)
          .to({radius : 14.5 }, 200)
          // .easing(TWEEN.Easing.Linear.InOut)
          .start(); 
        }

      }

      function idlBehav() {
        console.log('idle');
        camera.attachControl(canvas, true);   
        camera.useAutoRotationBehavior = true;
      }

      let moveIdleTimer = null
      scene.onPointerMove = function(event){
        if(camera.radius == 15 && !isDragging) {
          clearTimeout(moveIdleTimer)
          moveIdleTimer = setTimeout(idlBehav, 2000);
        }

        if(isMouseDown) {
          isDragging = true
          bgContainer.classList.add('active')
        }else {
          bgContainer.classList.remove('active')
        }
        const delta = (event.layerX - mouseX) / window.innerWidth;

        /*if(Math.abs(delta) > 0.01){
          isDragging = true;
        }*/

        /*if(isDragging){
        
          //cubeModel.rotation.y -= 0.25 * delta;
          rotation -= 0.25 * delta;
          
        }*/
        
      }

      // Register a render loop to repeatedly render the scene
      engine.runRenderLoop(function () {

        TWEEN.update();

        //if(cubeModel){
          //cubeModel.rotation.y = BABYLON.Scalar.Lerp(cubeModel.rotation.y, rotation , 0.1);
        //}
        
        scene.render();
      });

      // Watch for browser/canvas resize events
      window.addEventListener("resize", function () {
        engine.resize();
      });

      function toggleContentOverlay(){

        leftBigImg.children[0].pause();
        
        contentOverlay.style.opacity = 0;
        contentOverlay.style.zIndex = -1;
        
      }

    </script>
  </body>
</html>